function [ evtable newlut ] = nlFT_compressFTEvents(evstructarray, typelut)

% function [ evtable newlut ] = nlFT_compressFTEvents(evstructarray, typelut)
%
% This compresses a Field Trip event list by converting type labels into
% numbers, removing "offset" and "duration" if empty, and storing the result
% as a table. MatLab structures have more overhead and MatLab cell arrays
% have a _lot_ of overhead, so the result takes up much less memory.
%
% This is intended to be used with event lists generated by the LoopUtil
% library, which store TTL state changes as events with "type" holding the
% channel label.
%
% FIXME - Fallback for numeric rather than character "type" data is to copy
% the type field without translation and return an empty LUT.
%
% "evstructarray" is the Field Trip event list (structure array).
% "typelut" is a cell array containing values expected in the "type" field.
%   For event lists generated by the LoopUtil library, this should be the
%   "label" field from the Field Trip header (channel label list).
%
% "evtable" is a table containing data from the event list.
% "newlut" is a copy of "typelut" with additional entries for any "type"
%   values that weren't recognized.


% Initialize to sane output.
evtable = table();
newlut = typelut;

if length(evstructarray) > 0

  % Initialize output with the "sample" and "value" fields.
  % Tolerate the "values are strings" case.

  evtable.sample = transpose( [ evstructarray(:).sample ] );
  if isnumeric(evstructarray(1).value) || islogical(evstructarray(1).value)
    evtable.value = transpose( [ evstructarray(:).value ] );
  else
    % NOTE - This will be much larger than numeric data!
    evtable.value = transpose( { evstructarray(:).value } );
  end


  % Convert the type array.
  % This may or may not contain numeric data.
  % If it's numeric, don't translate it.

  if isnumeric(evstructarray(1).type) || islogical(evstructarray(1).type)
    % Copy "type" as-is and return an empty LUT to signal this case.
    evtable.type = transpose( [ evstructarray(:).type ] );
    newlut = {};
  else
    typevalsraw = transpose( { evstructarray(:).type } );
    [ typevalscooked newlut ] = helper_lookupTypes(typevalsraw, typelut);
    evtable.type = typevalscooked;
  end


  % Only copy offset and/or duration if they're non-empty non-cell values.

  if (~isempty(evstructarray(1).offset)) && (~iscell(evstructarray(1).offset))
    evtable.offset = transpose( [ evstructarray(:).offset ] );
  end

  if (~isempty(evstructarray(1).duration)) ...
    && (~iscell(evstructarray(1).duration))
    evtable.duration = transpose( [ evstructarray(:).duration ] );
  end

end


% Done.

end



%
% Helper functions.


% This looks up type values and converts them to LUT indices.
% Any unknown type values are added to the LUT.
% This expects to deal with cell arrays containing character strings.

function [ typecodes newlut ] = helper_lookupTypes( typevals, oldlut )

  typecodes = nan(size(typevals));
  newlut = oldlut;

  lutcount = length(newlut);
  uniquetypes = unique(typevals);

  for uidx = 1:length(uniquetypes)
    thistype = uniquetypes{uidx};
    thisidx = find(strcmp(thistype, newlut));

    if isempty(thisidx)
      lutcount = lutcount + 1;
      newlut{lutcount} = thistype;
      thisidx = lutcount;
    end

    thismask = strcmp(thistype, typevals);
    typecodes(thismask) = thisidx;
  end

  % FIXME - Sanity check. This shouldn't be possible.
  if any(isnan(typecodes))
    disp('###  [nlFT_compressFTEvents]  Couldn''t look up type codes!');
  end

end



%
% This is the end of the file.
