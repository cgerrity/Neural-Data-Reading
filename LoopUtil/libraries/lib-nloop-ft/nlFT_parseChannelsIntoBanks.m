function bankdata = nlFT_parseChannelsIntoBanks( chanlabels, wavedata )

% function bankdata = nlFT_parseChannelsIntoBanks( chanlabels, wavedata )
%
% This tries to identify channels' banks by parsing channel labels, and
% optionally divides one trial's data into per-bank data. This will only
% work with channel labels generated by the LoopUtil library (i.e. with
% data read using the LoopUtil Field Trip I/O functions).
%
% "chanlabels" is a cell array containing channel names. This is normally
%   taken from header.label or rawdata.label.
% "wavedata" is a Nchans*Nsamples matrix containing waveform data. This is
%   normally taken from rawdata.trial{k}. An empty matrix skips data copying.
%
% "bankdata" is a structure indexed by LoopUtil bank identifier. Each field
%   contains a bank data structure with a "label" field containing a cell
%   array of FT channel labels, a "channum" field containing a vector of
%   LoopUtil channel indices, and optionally a "wavedata" field containing
%   a Nchans*Nsamples matrix of waveform data.


bankdata = struct();


% First pass: Store channel information.

for cidx = 1:length(chanlabels)

  thislabel = chanlabels{cidx};
  [ bankid chanid ] = nlFT_parseFTName(thislabel);

  if ~isfield( bankdata, bankid )
    bankdata.(bankid) = struct( 'label', {{}}, 'channum', [] );
  end

  bankdata.(bankid).label = [ bankdata.(bankid).label {thislabel} ];
  bankdata.(bankid).channum = [ bankdata.(bankid).channum chanid ];

end


% Second pass: Copy waveform data if requested.

if ~isempty(wavedata)

  banklist = fieldnames(bankdata);
  for bidx = 1:length(banklist)

    thisbank = banklist{bidx};
    thischanlist = bankdata.(thisbank).label;

    chanmask = ismember(chanlabels, thischanlist);
    bankdata.(thisbank).wavedata = wavedata(chanmask,:);

  end

end


% Done.

end


%
% This is the end of the file,
