function data = ...
  nlFT_readTableData( fname, header, firstsample, lastsample, chanidxlist )

% function data = ...
%   nlFT_readTableData( fname, header, firstsample, lastsample, chanidxlist )
%
% This constructs Field Trip waveform data based on information previously
% supplied to nlFT_initReadTable(). The idea is to be able to give Field
% Trip a way to read non-uniformly-sampled tabular data as waveform data.
%
% This is intended to be called by ft_read_data() via the "dataformat"
% argument.
%
% NOTE - This returns monolithic data (a 2D matrix), not epoched data.
%
% "fname" is the filename passed to ft_read_data(). This is ignored.
% "header" is the Field Trip header returned by nlFT_readTableHeader().
% "firstsample" is the index of the first sample to read.
% "lastsample" is the index of the last sample to read.
% "chanidxlist" is a vector containing Field Trip channel indices to read.
%
% "data" is the resulting 2D data matrix.


% Import global variables.

global nlFT_readTable_datatable;
global nlFT_readTable_chancolumns;
global nlFT_readTable_timecolumn;
global nlFT_readTable_timefirst;
global nlFT_readTable_timelast;
global nlFT_readTable_samplespertimeunit;
global nlFT_readTable_samprate;

% If anything hasn't been initialized, it has a value of "[]".
% We can test for that with "isempty", just as with the empty table case.


% Initialize to an error value.
data = [];


% Proceed if we've configured a table.
if ~isempty(nlFT_readTable_datatable)

  % Get metadata.
  % This had better have been generated by nlFT_readTableHeader(), or we'll
  % be in serious trouble.

  sampcount = header.nSamples;
  chanlabels = header.label;

  tablecols = nlFT_readTable_datatable.Properties.VariableNames;


  % Get a (valid) sample range and a time range.

  firstsample = max(firstsample,1);
  lastsample = max(lastsample,1);
  firstsample = min(firstsample, sampcount);
  lastsample = min(lastsample, sampcount);

  samprange = firstsample:lastsample;

  firsttime = nlFT_readTable_timefirst ...
    + ( (firstsample - 1) / nlFT_readTable_samplespertimeunit );
  lasttime = nlFT_readTable_timefirst ...
    + ( (lastsample - 1) / nlFT_readTable_samplespertimeunit );


  % Get a row mask. Also calculate sample indices for each table row.

  rowtimes = nlFT_readTable_datatable.(nlFT_readTable_timecolumn);
  rowmask = (rowtimes >= firsttime) & (rowtimes <= lasttime);
  rowsamps = 1 + ( (rowtimes - nlFT_readTable_timefirst) ...
    * nlFT_readTable_samplespertimeunit );


  % Iterate columns/channels, building output.

  for cidx = 1:length(chanidxlist)

    thischannum = chanidxlist(cidx);
    thischanlabel = chanlabels{thischannum};

    % Initialize to a 1xNsamps vector, in case of missing columns.
    thisdata = zeros(1,length(samprange));

    if ismember(thischanlabel, tablecols)
      % Get table values and interpolate.
      % NOTE - Pass the entire column to the interpolation function, to avoid
      % edge effects.

      thiscol = nlFT_readTable_datatable.(thischanlabel);
      thisdata = nlProc_interpolateSeries( rowsamps, thiscol, samprange );

      if ~iscolumn(thisdata)
        thisdata = transpose(thisdata);
      end
    end

    % Store this data.
    data(cidx,:) = thisdata;

  end

end


% Done.

end


%
% This is the end of the file.
